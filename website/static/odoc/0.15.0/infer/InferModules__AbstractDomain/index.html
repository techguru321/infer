<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>InferModules__AbstractDomain (infer.InferModules__AbstractDomain)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../index.html">infer</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">InferModules__AbstractDomain</span></h1></header><div class="spec module" id="module-F"><a href="#module-F" class="anchor"></a><div class="def module"><code><span class="keyword">module </span>F = Format</code></div><div class="doc"></div></div><div class="spec module" id="module-Types"><a href="#module-Types" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Types/index.html">Types</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><p>Abstract domains and domain combinators</p><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><div class="def module-type"><code><span class="keyword">module type </span><a href="module-type-S/index.html">S</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><div class="spec module-type" id="module-type-WithBottom"><a href="#module-type-WithBottom" class="anchor"></a><div class="def module-type"><code><span class="keyword">module type </span><a href="module-type-WithBottom/index.html">WithBottom</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"><p>A domain with an explicit bottom value</p></div></div><div class="spec module-type" id="module-type-WithTop"><a href="#module-type-WithTop" class="anchor"></a><div class="def module-type"><code><span class="keyword">module type </span><a href="module-type-WithTop/index.html">WithTop</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"><p>A domain with an explicit top value</p></div></div><div class="spec module" id="module-BottomLifted"><a href="#module-BottomLifted" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="BottomLifted/index.html">BottomLifted</a> : <span class="keyword">functor</span> (<a href="BottomLifted/argument-1-Domain/index.html">Domain</a> : <a href="index.html#module-type-S">S</a>) -&gt; <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"><p>Lift a pre-domain to a domain</p></div></div><div class="spec include"><div class="doc"><p>Create a domain with Top element from a pre-domain</p></div><details open="open"><summary><span class="def"><code><span class="keyword">include </span><span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><div class="spec module" id="module-TopLifted"><a href="#module-TopLifted" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="TopLifted/index.html">TopLifted</a> : <span class="keyword">functor</span> (<a href="TopLifted/argument-1-Domain/index.html">Domain</a> : <a href="index.html#module-type-S">S</a>) -&gt; <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div></details></div><div class="spec module" id="module-Pair"><a href="#module-Pair" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Pair/index.html">Pair</a> : <span class="keyword">functor</span> (<a href="Pair/argument-1-Domain1/index.html">Domain1</a> : <a href="index.html#module-type-S">S</a>) -&gt; <span class="keyword">functor</span> (<a href="Pair/argument-2-Domain2/index.html">Domain2</a> : <a href="index.html#module-type-S">S</a>) -&gt; <a href="index.html#module-type-S">S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="Pair/index.html#type-astate">astate</a><span class="keyword"> = </span><a href="Pair/argument-1-Domain1/index.html#type-astate">Domain1.astate</a><span class="keyword"> * </span><a href="Pair/argument-2-Domain2/index.html#type-astate">Domain2.astate</a></code></div><div class="doc"><p>Cartesian product of two domains.</p></div></div><div class="spec module" id="module-FiniteSetOfPPSet"><a href="#module-FiniteSetOfPPSet" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="FiniteSetOfPPSet/index.html">FiniteSetOfPPSet</a> : <span class="keyword">functor</span> (<a href="FiniteSetOfPPSet/argument-1-PPSet/index.html">PPSet</a> : <a href="../../InferStdlib/InferStdlib/PrettyPrintable/index.html#module-type-PPSet">InferStdlib.PrettyPrintable.PPSet</a>) -&gt; <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"><p>Lift a PPSet to a powerset domain ordered by subset. The elements of the set should be drawn from
a *finite* collection of possible values, since the widening operator here is just union.</p></div></div><div class="spec module" id="module-FiniteSet"><a href="#module-FiniteSet" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="FiniteSet/index.html">FiniteSet</a> : <span class="keyword">functor</span> (<a href="FiniteSet/argument-1-Element/index.html">Element</a> : <a href="../../InferStdlib/InferStdlib/PrettyPrintable/index.html#module-type-PrintableOrderedType">InferStdlib.PrettyPrintable.PrintableOrderedType</a>) -&gt; <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"><p>Lift a set to a powerset domain ordered by subset. The elements of the set should be drawn from
a *finite* collection of possible values, since the widening operator here is just union.</p></div></div><div class="spec module" id="module-InvertedSet"><a href="#module-InvertedSet" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="InvertedSet/index.html">InvertedSet</a> : <span class="keyword">functor</span> (<a href="InvertedSet/argument-1-Element/index.html">Element</a> : <a href="../../InferStdlib/InferStdlib/PrettyPrintable/index.html#module-type-PrintableOrderedType">InferStdlib.PrettyPrintable.PrintableOrderedType</a>) -&gt; <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"><p>Lift a set to a powerset domain ordered by superset, so the join operator is intersection</p></div></div><div class="spec module" id="module-MapOfPPMap"><a href="#module-MapOfPPMap" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="MapOfPPMap/index.html">MapOfPPMap</a> : <span class="keyword">functor</span> (<a href="MapOfPPMap/argument-1-PPMap/index.html">PPMap</a> : <a href="../../InferStdlib/InferStdlib/PrettyPrintable/index.html#module-type-PPMap">InferStdlib.PrettyPrintable.PPMap</a>) -&gt; <span class="keyword">functor</span> (<a href="MapOfPPMap/argument-2-ValueDomain/index.html">ValueDomain</a> : <a href="index.html#module-type-S">S</a>) -&gt; <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"><p>Map domain ordered by union over the set of bindings, so the bottom element is the empty map.
Every element implicitly maps to bottom unless it is explicitly bound to something else.
Uses PPMap as the underlying map</p></div></div><div class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Map/index.html">Map</a> : <span class="keyword">functor</span> (<a href="Map/argument-1-Key/index.html">Key</a> : <a href="../../InferStdlib/InferStdlib/PrettyPrintable/index.html#module-type-PrintableOrderedType">InferStdlib.PrettyPrintable.PrintableOrderedType</a>) -&gt; <span class="keyword">functor</span> (<a href="Map/argument-2-ValueDomain/index.html">ValueDomain</a> : <a href="index.html#module-type-S">S</a>) -&gt; <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"><p>Map domain ordered by union over the set of bindings, so the bottom element is the empty map.
Every element implicitly maps to bottom unless it is explicitly bound to something else</p></div></div><div class="spec module" id="module-InvertedMap"><a href="#module-InvertedMap" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="InvertedMap/index.html">InvertedMap</a> : <span class="keyword">functor</span> (<a href="InvertedMap/argument-1-Key/index.html">Key</a> : <a href="../../InferStdlib/InferStdlib/PrettyPrintable/index.html#module-type-PrintableOrderedType">InferStdlib.PrettyPrintable.PrintableOrderedType</a>) -&gt; <span class="keyword">functor</span> (<a href="InvertedMap/argument-2-ValueDomain/index.html">ValueDomain</a> : <a href="index.html#module-type-S">S</a>) -&gt; <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"><p>Map domain ordered by intersection over the set of bindings, so the top element is the empty
map. Every element implictly maps to top unless it is explicitly bound to something else</p></div></div><div class="spec include"><div class="doc"><p>Boolean domain ordered by p || ~q. Useful when you want a boolean that's true only when it's
true in both conditional branches.</p></div><details open="open"><summary><span class="def"><code><span class="keyword">include </span><span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><div class="spec module" id="module-BooleanAnd"><a href="#module-BooleanAnd" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="BooleanAnd/index.html">BooleanAnd</a> : <a href="index.html#module-type-S">S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="module-type-S/index.html#type-astate">astate</a><span class="keyword"> = </span>bool</code></div><div class="doc"></div></div></details></div><div class="spec module" id="module-BooleanOr"><a href="#module-BooleanOr" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="BooleanOr/index.html">BooleanOr</a> : <a href="index.html#module-type-WithBottom">WithBottom</a><span class="keyword"> with </span><span class="keyword">type </span><a href="module-type-WithBottom/index.html#type-astate">astate</a><span class="keyword"> = </span>bool</code></div><div class="doc"><p>Boolean domain ordered by ~p || q. Useful when you want a boolean that's true only when it's
true in one conditional branch.</p></div></div><div class="spec module-type" id="module-type-MaxCount"><a href="#module-type-MaxCount" class="anchor"></a><div class="def module-type"><code><span class="keyword">module type </span><a href="module-type-MaxCount/index.html">MaxCount</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><div class="spec module" id="module-CountDomain"><a href="#module-CountDomain" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="CountDomain/index.html">CountDomain</a> : <span class="keyword">functor</span> (<a href="CountDomain/argument-1-MaxCount/index.html">MaxCount</a> : <a href="index.html#module-type-MaxCount">MaxCount</a>) -&gt; <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"><p>Domain keeping a non-negative count with a bounded maximum value. The count can be only
incremented and decremented</p></div></div><div class="spec module" id="module-StackDomain"><a href="#module-StackDomain" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="StackDomain/index.html">StackDomain</a> : <span class="keyword">functor</span> (<a href="StackDomain/argument-1-Element/index.html">Element</a> : <a href="../../InferStdlib/InferStdlib/PrettyPrintable/index.html#module-type-PrintableOrderedType">InferStdlib.PrettyPrintable.PrintableOrderedType</a>) -&gt; <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"><p>Domain whose members are stacks of elements (lists, last pushed is head of the list),
partially ordered by the prefix relation (<code class="code">c;b;a</code> &lt;= <code class="code">b;a</code>), and whose join computes the
longest common prefix (so <code class="code">c;b;a</code> join <code class="code">f;g;b;c;a</code> = <code class="code">a</code>), so the top element is the empty
stack.</p></div></div></body></html>